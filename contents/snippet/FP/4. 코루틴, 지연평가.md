---
title: "[FP] - Coroutine과 Lazy Evaluation"
description: 함수형 프로그래밍에서 등장하는 Lazy Evaluation과 그에 관한 Coroutine에 대해 알아보자
image:
date: 2024-07-04T22:35
series : FP
tags:
  - FP
  - 패러다임
slug: coroutine-lazy-evaluation
---

함수형 프로그래밍을 접하다 보면 `Lazy Evaluation(지연 평가)`를 자주 마주치게 됩니다.

지연평가는 함수형 프로그래밍을 지원하는 `Lodash`,`Rxjs`, `Fxjs` 와 같은 라이브러리에서도 지원하는 기능입니다.

지연 평가는 말 그대로 `계산이 필요한 시점까지 계산을 미루는 것`입니다.

### 엄격한 평가

지연평가를 이해하기위해선 기본 동작인 엄격한 평가가 무엇인지 알고 비교하는 편이 좋습니다.

```ts
go(
	()=> [0,1,2,3,4,5],
	map(i=> i+10)
	filter(isEven),
	slice(0,2),
	console.log
)
```

엄격한 평가는 각각 함수의 계산이 `모두 종료되어야` 다음 단계를 수행합니다.

즉, 예시에서 map 6번, filter 6번, slice 2번 총 14번 함수가 실행됩니다. 코드상으로 문제는 없지만 좀 더 효율적으로 생각해보자면 먼저 filter를 통해 필터링을 하고 나머지를 1씩 더하면 쓸데없는 연산없이 효율적인 작업이 가능해 보입니다.

![엄격한 평가는 평가의 흐름이 왼쪽에서 오른쪽으로 흐른다.](https://i.imgur.com/Y4676qr.png)

### 지연 평가

지연평가는 엄격한 평가와는 다르게 흐름이 위에서 아래로 흐릅니다.

```ts
go(
	()=> [0,1,2,3,4,5],
	L.map(i=> i+10)
	L.filter(isEven),
	L.slice(0,2),
	console.log
)
```

> [!info] 구현은 나중에!
>
> 지연 평가를 지원하는 코드는 내부 구현체를 코루틴을 이용해 구현합니다. 이는 다음 글에서 자세하게 다루겠습니다.

해당 코드에서 모든 원소에 대해 계산을 한 뒤 다음 함수로 넘기는 것이 아닌 원소 한개씩 계산합니다.

![지연 평가는 평가의 흐름이 위에서 아래로 흐른다.](https://i.imgur.com/rqcs875.png)

지연 평가를 이용하면 표와 같이 3까지 계산후 원하는 결과값을 얻었으므로 원소 4, 5 에 대한 계산을 하지 않는 것을 확인할 수 있습니다.

이를 예제코드에서 배열의 원소 개수를 1,000,000개로 수정한 뒤 적용한 성능을 비교해보겠습니다.

```ts
// 엄격한 평가

go(
  range(1, 100000000),
  map((a) => a + 1),
  filter((a) => a % 2 === 0),
  take(10),
  log()
);

// 지연 평가

go(
  () => L.range(1, 100000000),
  L.map((a) => a + 1),
  L.filter((a) => a % 2 === 0),
  take(10),
  log()
);

// perpomence를 통해 비교한 결과

// Eager execution time: 7330.468124999999
// Lazy execution time: 0.4093329999996058
```

지연평가가 압도적인 성능을 나타냄을 알 수 있습니다.

지연평가를 구현하기 위에서는 제너레이터를 이해해야 하는데 이를 위해 코루틴이 무엇인지 알면 더 쉽게 이해할 수 있습니다.

### Coroutine(코루틴)

코루틴은 프로그래밍에서 독립적으로 실행될 수 있는 서브루틴의 한 형태입니다.

서브루틴은 그럼 무엇일까요? 서브루틴은 프로그래밍에서 여러번 호출될 수 있는 독립적인 코드 블록을 말합니다. 예컨대 함수는 서브루틴이라고 말할 수 있죠.

그렇다면 코루틴은 어떤 서브루틴일까요? 코루틴은 일반적인 서브루틴과 다르게 실행 중간에 일시 중단하고 나중에 이어서 실행할 수 있는 능력을 가지고 있습니다. 이러한 특성으로 병행성(Concurrency, 동시성)을 구현하는 데 매우 유용하게 사용됩니다.

> [!info] 병행성과, 병렬성
>
> - 병행성(Concurrency, 동시성) : 논리적으로 병렬 작업이 실행되는 것 처럼 보이는 것 (코루틴)
> - 병렬성(Parallelism) : 물리적으로 병렬로 작업이 실행되는 것 (쓰레드)

그림으로 보면 다음과 같습니다.

![](https://i.imgur.com/sDQfC1q.png)

서브루틴은 실행 후 반환문을 통해 원래 위치로 돌아옵니다.

![](https://i.imgur.com/Q3vnP1c.png)

반면 코루틴은 반환문이 없더라도 임의 지점(yield)에서 실행 중 동작을 중단하고 이후 해당 지점에서부터 실행을 재개합니다.

이를 통해 코루틴의 특징을 정리해보자면 다음과 같습니다.

> [!info] GPT
>
> - **일시 중단과 재개**: 코루틴은 실행 중 언제든지 일시 중단하고, 이후에 그 지점부터 다시 실행을 재개할 수 있습니다. 이는 코루틴이 자신의 실행 상태를 저장하고 복원할 수 있기 때문에 가능합니다.
> - **동시성 구현**: 여러 코루틴들이 동시에 실행되면서, 하나의 스레드에서 시간을 적절히 분배하여 병행성을 구현할 수 있습니다. 이는 스레드를 생성하고 관리하는 비용을 줄이면서도 병행성을 달성할 수 있는 장점을 제공합니다.
> - **비동기 프로그래밍**: 코루틴은 비동기 코드를 보다 직관적이고 구조화된 방식으로 작성할 수 있도록 돕습니다. 특히 이벤트 기반 프로그래밍이나 네트워크 작업과 같은 경우에 매우 유용하게 쓰입니다.
> - **메모리 사용**: 스레드와 달리 코루틴은 상대적으로 작은 메모리를 사용합니다. 각 코루틴은 일시 중단된 상태에서도 자신의 상태를 보존하기 위한 메모리만 사용하므로, 많은 수의 코루틴을 생성해도 시스템에 부하를 거의 주지 않습니다.

자바스크립트를 통해 서버와 통신을 해보셨다면 여러분도 이미 코루틴을 사용해보신 경험이 있을 겁니다. 없다고요? 아래 코드를 보시죠

```ts
const get = async()=>{
	const res = await fetch(...)
	return res
}
```

어떤가요? 사실 비동기 프로그래밍을 위해 사용하는 `async/await`가 코루틴입니다.

`async` 함수는 `await`키워드를 통해 `Promise`가 처리될 때까지 함수의 실행을 일시 중단하고 처리 후 다시 실행합니다. 또한 await는 기본적으로 Promise를 기다리지만, 비동기 작업을 수행하는 다른 async함수나 Promise객체를 기다릴 수 있습니다.

자바스크립트에서는 제너레이터 함수를 이용해 코루틴을 구현할 수 있습니다. 제너레이터 함수를 통해 코루틴, 지연로딩을 구현하는 것은 다음 글에서 해보도록 하겠습니다.

### 참고자료

https://inpa.tistory.com/entry/LODASH-%F0%9F%93%9A-%EC%A7%80%EC%97%B0-%ED%8F%89%EA%B0%80-%EC%9B%90%EB%A6%AC-lodash%EB%8A%94-%EC%98%A4%ED%9E%88%EB%A0%A4-%EC%84%B1%EB%8A%A5%EC%9D%B4-%EC%A2%8B%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8B%A4

https://dev.gmarket.com/82
